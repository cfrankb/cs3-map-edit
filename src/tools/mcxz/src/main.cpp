#include <stdio.h>
#include <cstdlib>
#include <time.h>
#include <unistd.h>
#include <string>
#include <cstring>
#include <unordered_map>
#include <map>
#include <vector>
#include <iostream>
#include <chrono>
#include <ctime>
#include <format>
#include <filesystem>
#include <minizip/unzip.h>
#include "../../../shared/FileWrap.h"
#include "../../../shared/FrameSet.h"
#include "../../../shared/Frame.h"
#include "tileset.h"

#define DEFAULT_APP_NAME "cs3-runtime-sdl"

enum
{
    ENCODING_RGB565,    // 2 bytes
    ENCODING_RGB565BGR, // 2 bytes
    ENCODING_RGBX555,   // 2 bytes
    ENCODING_RGBX888P,  // 1 byte
    ENCODING_RGB888,    // 3 byte
    ENCODING_RGBX888,   // 4 byte
};

const char *ENCODING_RGB[] = {
    "565",
    "565BGR",
    "X555",
    "X888P",
    "888",
    "X888",
};

typedef struct
{
    uint8_t ch;           // char for ascii map (deprecated)
    std::string name;     // WALLS93
    uint8_t type;         // 0x03
    std::string typeName; // TYPE_WALLS
    std::string define;   // TILES_WALLS93
    std::string basename; // walls93.obl
    uint8_t score;        // points to add
    int8_t health;        // health to add or remove
    uint8_t flags;        // action
    uint8_t speed;        // SLOW, NORMAL, FAST
    uint8_t ai;           // ai
    bool hidden;          // hide tile in IDE
    bool unused;          // is unused asset?
    std::string notes;    // notes about this animation
} Tile;

typedef struct
{
    uint16_t pixelWidth;
    uint8_t encoding;
    bool flipPixels;
    bool headerless;
    bool outputPNG;
    bool diet;
    std::string appName;
} AppSettings;

struct group_t
{
    std::string name;
    int count;
};

typedef std::vector<std::string> StringVector;
typedef std::vector<Tile> TileVector;
typedef std::vector<std::string> StrVector;
typedef std::map<std::string, StringVector> Config;
typedef std::unordered_map<std::string, uint8_t> StrVal;
typedef std::map<std::string, StrVal> MapStrVal;
typedef std::unordered_map<uint32_t, uint8_t> Palette;

template <typename StringType>
StringType mid(const StringType &str, size_t start, size_t length = std::string::npos)
{
    if (start >= str.size())
        return {};
    return str.substr(start, length);
}

const char *AUTOGENERATED = "//////////////////////////////////////////////////\n"
                            "// autogenerated\n\n";

constexpr const char LICENSE[] =
    "/*\n"
    "    {0}\n"
    "    Copyright (C) {1} Francois Blanchette\n"
    "\n"
    "    This program is free software: you can redistribute it and/or modify\n"
    "    it under the terms of the GNU General Public License as published by\n"
    "    the Free Software Foundation, either version 3 of the License, or\n"
    "    (at your option) any later version.\n"
    "\n"
    "    This program is distributed in the hope that it will be useful,\n"
    "    but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
    "    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n"
    "    GNU General Public License for more details.\n"
    "\n"
    "    You should have received a copy of the GNU General Public License\n"
    "    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n"
    "*/\n";

void writeLicense(const AppSettings &appSettings, CFileWrap &tfile)
{
    std::time_t t = std::time(0); // Get the time now
    std::tm *now = std::localtime(&t);
    tfile += std::format(LICENSE, appSettings.appName, now->tm_year + 1900);
}

void splitString(const std::string str,
                 StringVector &list)
{
    int i = 0;
    unsigned int j = 0;
    while (j < str.length())
    {
        if (isspace(str[j]))
        {
            list.push_back(str.substr(i, j - i));
            while (isspace(str[j]) && j < str.length())
            {
                ++j;
            }
            i = j;
            continue;
        }
        ++j;
    }
    list.push_back(str.substr(i, j - i));
}

std::string str2upper(const std::string &in)
{
    char t[in.length() + 1];
    strcpy(t, in.c_str());
    char *p = t;
    while (*p)
    {
        if (*p == '.')
        {
            break;
        }
        *p = toupper(*p);
        ++p;
    }
    return t;
}

// RGB 565
uint16_t rgb888torgb565(const uint8_t *rgb888Pixel)
{
    const uint8_t &red = rgb888Pixel[0];
    const uint8_t &green = rgb888Pixel[1];
    const uint8_t &blue = rgb888Pixel[2];

    const uint16_t b = (blue >> 3) & 0x1f;
    const uint16_t g = ((green >> 2) & 0x3f) << 5;
    const uint16_t r = ((red >> 3) & 0x1f) << 11;
    return (uint16_t)(r | g | b);
}

// RGB 555
uint16_t rgb888torgb555(const uint8_t *rgb888Pixel)
{
    const uint8_t &red = rgb888Pixel[0];
    const uint8_t &green = rgb888Pixel[1];
    const uint8_t &blue = rgb888Pixel[2];

    const uint16_t b = (blue >> 3) & 0x1f;
    const uint16_t g = ((green >> 3) & 0x1f) << 5;
    const uint16_t r = ((red >> 3) & 0x1f) << 10;
    return (uint16_t)(r | g | b);
}

/**
 * @brief generate test file
 *
 * @return int
 */
int test()
{
    CFileWrap tfileTiny;
    tfileTiny.open("out/test_output.obl", "wb");

    CFileWrap sfile;
    if (sfile.open("obl5/annie2.obl", "rb"))
    {
        CFrameSet images;
        if (images.extract(sfile))
        {
            printf("images:%d\n", images.getSize());
        }
        int count = images.getSize();
        CFrameSet imagesTiny;
        for (int i = 0; i < count; ++i)
        {
            CFrame *s = images[i];
            CFrame *t = new CFrame;
            t->copy(s);
            t->resize(32, 32);
            int shiftRight = (32 - s->len()) / 2;
            for (int j = 0; j < shiftRight; ++j)
            {
                t->shiftRIGHT();
            }
            int shiftDown = (32 - s->hei()) / 2;
            for (int j = 0; j < shiftDown; ++j)
            {
                t->shiftDOWN();
            }
            t->shrink();
            imagesTiny.add(t);
        }

        CTileSet tiles(16, 16, count);
        for (int i = 0; i < count; ++i)
        {
            printf("image:%d\n", i);
            CFrame *frame = imagesTiny[i];
            u_int32_t *rgb888 = frame->getRGB();
            int pixels = frame->len() * frame->hei();
            uint16_t rgb565[pixels];

            for (int j = 0; j < pixels; ++j)
            {
                rgb565[j] = rgb888torgb565(reinterpret_cast<uint8_t *>(&rgb888[j]));
            }
            tiles.set(i, rgb565);
        }

        imagesTiny.write(tfileTiny);
        tiles.write("out/test_output.mcz");
    }
    else
    {
        puts("failed to open");
    }

    return EXIT_SUCCESS;
}

/**
 * @brief parse raw config file data
 *
 * @param conf
 * @param list
 * @param src
 * @return true
 * @return false
 */

bool parseConfig(Config &conf,
                 StrVector &list,
                 const char *src)
{
    char *ptr = nullptr;
    FILE *sfile = fopen(src, "rb");
    if (sfile)
    {
        fseek(sfile, 0, SEEK_END);
        long size = ftell(sfile);
        ptr = new char[size + 1];
        ptr[size] = 0;
        fseek(sfile, 0, SEEK_SET);
        fread(ptr, size, 1, sfile);
        fclose(sfile);
    }
    else
    {
        fprintf(stderr, "can't open %s\n", src);
        return false;
    }
    char *s = ptr;

    int line = 0;
    char *sName = nullptr;
    while (s && *s)
    {
        ++line;
        // find next line
        char *n = strstr(s, "\n");
        char *b = nullptr;
        if (n)
        {
            // truncate line on return char
            *n = 0;
            b = n - 1;
            ++n;
        }

        // remove comment
        char *c = strstr(s, "#");
        if (c)
        {
            *c = 0;
            if (c < b)
            {
                b = c - 1;
            }
        }

        // trim right
        while (b >= s && isspace(*b))
        {
            *b = 0;
            --b;
        }

        // trim left
        while (isspace(*s))
        {
            ++s;
        }

        if (*s != '\0')
        {
            if (*s == '[')
            {
                sName = s + 1;
                // section header
                char *se = strstr(s, "]");
                if (se)
                {
                    *se = 0;
                    list.push_back(sName);
                }
                else
                {
                    printf("section head `%s` on line %d missing right bracket.\n", s, line);
                }
            }
            else
            {
                if (sName != nullptr)
                {
                    conf[sName].push_back(s);
                }
                else
                {
                    printf("file def on line %d without section.\n", line);
                }
            }
        }
        s = n;
    }
    delete[] ptr;
    return true;
}

/**
 * @brief generate constants list
 *
 * @param rows
 * @param prefix
 * @param constMap
 * @param constList
 * @return true
 * @return false
 */

bool processConst(StringVector &rows,
                  const char *prefix,
                  StrVal &constMap,
                  StringVector &constList)
{
    for (size_t i = 0; i < rows.size(); ++i)
    {
        StringVector list;
        splitString(rows[i], list);
        std::string key = str2upper(list[0]);
        if (list.size() < 2)
        {
            printf("missing second value for: %s\n", key.c_str());
            continue;
        }
        u_int8_t val = list[1].substr(0, 2) == "0x" ? std::stoi(list[1], 0, 16) : std::stoi(list[1], 0, 10);
        constMap[key] = val;
        const std::string name = std::format("{0}_{1}", prefix, key);
        const std::string tmp = std::format("#define {0:25s}0x{1:02x}\n", name, val);
        constList.push_back(tmp);
    }
    return true;
}

/** Write constants to special header file
 * @brief
 *
 * @param appSettings
 * @param constLists
 * @return true
 * @return false
 */
bool writeConstFile(const AppSettings &appSettings, Config &constLists)
{
    CFileWrap tfile;
    const char *fname = "out/sprtypes.h";
    const bool result = tfile.open(fname, "wb");
    if (result)
    {
        writeLicense(appSettings, tfile);
        tfile += AUTOGENERATED;
        tfile += "#pragma once\n";
        for (auto &it : constLists)
        {
            const StringVector &list = it.second;
            if (list.size() > 0)
            {
                tfile += "\n";
            }
            for (size_t i = 0; i < list.size(); ++i)
            {
                tfile += list[i].c_str();
            }
        }
        tfile.close();
    }
    else
    {
        printf("cannot create %s\n", fname);
    }
    return result;
}

/**
 * @brief take a filepath and create a tile name
 *
 * @param src
 * @return std::string
 */
std::string formatTitleName(const char *filepath)
{
    char t[256];
    const std::filesystem::path fsPath(filepath);
    const std::string filename = fsPath.filename().string();
    strcpy(t, filename.c_str());
    char *d = strstr(t, ".");
    if (d)
    {
        *d = 0;
    }
    return str2upper(t);
}

/** get the basename from the filepath
 * @brief Get the Basename object
 *
 * @param filepath
 * @return std::string
 */
std::string getBasename(const char *filepath)
{
    const std::filesystem::path fsPath(filepath);
    const std::string filename = fsPath.filename().string();
    return filename;
}

/**
 * @brief generate C++ header file for game project
 *
 * @param appSettings
 * @param section
 * @param sectionName
 * @param sectionBasename
 * @param tileDefs
 * @param fileStats
 * @param useTileDefs
 * @return true
 * @return false
 */

bool generateHeader(const AppSettings &appSettings,
                    const std::string section,
                    const std::string sectionName,
                    std::string const sectionBasename,
                    TileVector &tileDefs,
                    std::vector<group_t> &fileStats,
                    const bool useTileDefs)
{
    const std::string fnameHdr = section + "data.h";
    CFileWrap tfileHdr;
    if (!tfileHdr.open(fnameHdr.c_str(), "wb"))
    {
        fprintf(stderr, "can't create %s\n", fnameHdr.c_str());
        return false;
    }

    //////////////////////////////////////////////////////////////////////
    // file header

    writeLicense(appSettings, tfileHdr);
    tfileHdr += AUTOGENERATED;
    tfileHdr += "#pragma once\n\n";
    if (useTileDefs)
    {
        tfileHdr += "#include <cstdint>\n\n"
                    "typedef struct\n"
                    "{\n"
                    "    uint8_t flags;\n"
                    "    uint8_t type;\n"
                    "    uint8_t score;\n"
                    "    int8_t health;\n"
                    "    uint8_t speed;\n"
                    "    uint8_t ai;\n"
                    "    bool hidden;\n"
                    "    const char * basename;\n"
                    "} TileDef;\n"
                    "uint8_t getChTile(uint8_t i) ;\n"
                    "const TileDef * getTileDefs();\n"
                    "const TileDef & getTileDef(int i);\n\n";
    }
    else
    {
        for (auto &filestat : fileStats)
        {
            tfileHdr += std::format("#define {0:20s} 0x{1:02x}\n", filestat.name + "_LEN", filestat.count);
        }
        tfileHdr += "\n";
    }

    for (size_t i = 0; i < tileDefs.size(); ++i)
    {
        Tile &tile = tileDefs[i];
        tfileHdr += std::format("#define {0:20s} 0x{1:02x}\n", tile.define, i);
    }

    tfileHdr.close();
    return true;
}

/**
 * @brief generate C++ boilerplate data structures for the game
 *        to support the tileset
 *
 * @param appSettings
 * @param section
 * @param sectionBasename
 * @param tileDefs
 * @return true
 * @return false
 */

bool generateData(const AppSettings &appSettings,
                  const std::string section,
                  std::string const sectionBasename,
                  TileVector &tileDefs)
{
    const std::string fnameData = section + "data.cpp";
    CFileWrap tfileData;
    if (!tfileData.open(fnameData.c_str(), "wb"))
    {
        fprintf(stderr, "failed to create %s\n", fnameData.c_str());
        return false;
    }

    writeLicense(appSettings, tfileData);
    tfileData += AUTOGENERATED;
    tfileData += std::format("#include \"{}data.h\"\n", sectionBasename);
    tfileData += "#include \"sprtypes.h\"\n\n"
                 "const TileDef tileDefs[] = {\n";

    uint8_t chMap[128];
    memset(chMap, 0, sizeof(chMap));

    int warnings = 0;
    StringVector lines;
    size_t maxLenght = 0;
    for (size_t i = 0; i < tileDefs.size(); ++i)
    {
        Tile &tile = tileDefs[i];
        std::string basename = "\"" + tile.basename + "\"";
        std::string tmp = std::format("    {{0x{0:02x}, TYPE_{1}, {2}, {3}, {4}, {5}, {6}, {7}}}{8}",
                                      tile.flags, tile.typeName.c_str(),
                                      tile.score,
                                      tile.health,
                                      tile.speed,
                                      tile.ai,
                                      tile.hidden ? "true" : "false",
                                      appSettings.diet ? "nullptr" : basename.c_str(),
                                      i != tileDefs.size() - 1 ? ", " : " ");
        lines.push_back(tmp);
        maxLenght = std::max(maxLenght, tmp.length());
        if (tile.ch != 0)
        {
            if (chMap[tile.ch] != '\0')
            {
                Tile &tileOld = tileDefs[chMap[tile.ch]];
                fprintf(stderr, "conflict warning: char `%c` already assigned to %s. \n",
                        tile.ch, tileOld.name.c_str());
                ++warnings;
            }
            chMap[tile.ch] = i;
        }
    }

    char *padding = new char[maxLenght + 1];
    for (size_t i = 0; i < lines.size(); ++i)
    {
        Tile &tile = tileDefs[i];
        tfileData += lines[i];
        int spaces = maxLenght - lines[i].length();
        memset(padding, ' ', spaces);
        padding[spaces] = '\0';
        const std::string tmp = std::format("{0}// {1:02x} {2}\n",
                                            padding, i, tile.define);
        tfileData += tmp;
    }
    delete[] padding;
    tfileData += "};\n\n";
    if (!appSettings.diet)
    {
        tfileData += "const uint8_t chMap[] = {\n";
        for (size_t i = 0; i < sizeof(chMap); ++i)
        {
            tfileData += std::format("{0}0x{1:02x}{2}",
                                     i % 8 == 0 ? "    " : "",
                                     chMap[i],
                                     i % 8 == 7 ? ",\n" : ", ");
        }
        tfileData += "};\n\n";
        tfileData += "uint8_t getChTile(const uint8_t i)\n"
                     "{\n"
                     "  return chMap[i % sizeof(chMap)];\n"
                     "}\n\n";
    }
    tfileData += "const TileDef *getTileDefs()\n"
                 "{\n"
                 "  return tileDefs;\n"
                 "}\n\n"
                 "const TileDef &getTileDef(int i)\n"
                 "{\n"
                 "  return tileDefs[i];\n"
                 "}\n"
                 "\n";
    if (warnings)
        printf(">>>>%d warnings\n", warnings);
    tfileData.close();
    return true;
}

/**
 * @brief decode parameters in a tile-list section
 *
 * @param list
 * @param constConfig
 * @param start
 * @param end
 * @param ch
 * @param useTileDefs
 * @return Tile
 */
Tile parseFileParams(const StringVector &list,
                     MapStrVal &constConfig,
                     int &start,
                     int &end,
                     std::vector<uint8_t> &ch,
                     bool &useTileDefs)
{
    Tile tile{.ch = 0, .name = formatTitleName(list[0].c_str()), .typeName = "NONE", .score = 0};
    typedef struct
    {
        StrVal *map;
        std::string name;
        uint8_t *dest;
        bool combine;
    } Params;

    typedef std::unordered_map<char, Params> MapParams;
    MapParams mapParams = MapParams{
        {'^', {&constConfig["flags"], "flags", &tile.flags, true}},
        {'&', {&constConfig["speeds"], "speeds", &tile.speed, false}},
        {':', {&constConfig["ai"], "ai", &tile.ai, true}},
    };

    for (size_t i = 1; i < list.size(); ++i)
    {
        const std::string item = list[i];
        const std::string ref = item.length() > 0 ? str2upper(item.substr(1)) : "";
        std::size_t j;
        switch (item.c_str()[0])
        {
        case '@':
            start = std::stoi(item.substr(1));
            end = start + 1;
            j = item.find(":");
            if (j != std::string::npos &&
                !item.substr(j + 1).empty())
            {
                end = std::stoi(item.substr(j + 1)) + 1;
            }
            break;
        case 'x':
            ch.push_back(std::stoi(item.substr(1), 0, 16));
            break;

        default:
            if (item.length() == 1)
            {
                ch.push_back(static_cast<u_int8_t>(item[0]));
            }
            else if (item[0] == '$')
            {
                tile.score = std::stoi(item.substr(1), 0, 10);
            }
            else if (item[0] == '+')
            {
                tile.health = std::stoi(item.substr(1), 0, 10);
            }
            else if (item[0] == '-')
            {
                tile.health = -std::stoi(item.substr(1), 0, 10);
            }
            else if (item[0] == '*')
            {
                if (ref == "HIDDEN")
                {
                    tile.hidden = true;
                }
                else if (ref == "UNUSED")
                {
                    tile.unused = true;
                }
                else
                {
                    printf("unknown directive: %s\n", ref.c_str());
                }
            }
            else if (item[0] == '!')
            {
                tile.name = formatTitleName(item.substr(1).c_str());
            }
            else if (mapParams.count(item[0]) != 0)
            {
                Params &params = mapParams[item[0]];
                if (params.map->count(ref) != 0)
                {
                    if (params.combine)
                    {
                        *(params.dest) |= (*params.map)[ref];
                    }
                    else
                    {
                        *(params.dest) = (*params.map)[ref];
                    }
                }
                else
                {
                    printf("can't find %s: %s\n", params.name.c_str(), ref.c_str());
                }
            }
            else
            {
                useTileDefs = true;
                tile.typeName = item;
                if (constConfig["types"].count(item) == 0)
                {
                    printf("unknown type: %s\n", ref.c_str());
                }
                else
                {
                    tile.type = constConfig["types"][item];
                }
            }
        }
    }
    return tile;
}

/**
 * @brief generate a reference map with tileID/description pair (plain text)
 *        for developer sanity check
 *
 * @param section
 * @param tileDefs
 * @param generateHeader
 */

void writeMapFile(const std::string &section,
                  const TileVector &tileDefs,
                  const bool generateHeader)
{
    const std::string fnameMap = section + ".map";
    CFileWrap tfileMap;
    tfileMap.open(fnameMap.c_str(), "wb");
    for (size_t j = 0; j < tileDefs.size(); ++j)
    {
        Tile tile = tileDefs[j];
        std::string tmp;
        if (generateHeader)
        {
            tmp = std::format("0x{0:02x} {1:20s} {2:10s}\n", j, tile.basename, tile.typeName);
        }
        else
        {
            tmp = std::format("0x{0:02x} {1:20s}\n", j, tile.basename);
        }
        tfileMap += tmp;
    }
    tfileMap.close();
}

/**
 * @brief Extraxt png images from zip archive
 *
 * @param zipPath
 * @param images
 * @return true
 * @return false
 */
bool readZipFile(const std::string &zipPath, CFrameSet &images)
{
    unzFile zip = unzOpen(zipPath.c_str());
    if (!zip)
    {
        std::cerr << "Cannot open ZIP file: " << zipPath << "\n";
        return false;
    }

    if (unzGoToFirstFile(zip) != UNZ_OK)
    {
        std::cerr << "Cannot read first file in ZIP\n";
        unzClose(zip);
        return false;
    }

    do
    {
        char filename[256];
        unz_file_info fileInfo;
        if (unzGetCurrentFileInfo(zip, &fileInfo, filename, sizeof(filename), nullptr, 0, nullptr, 0) != UNZ_OK)
        {
            std::cerr << "Cannot get file info\n";
            break;
        }

        // std::cout << "Found file: " << filename << " (" << fileInfo.uncompressed_size << " bytes)\n";
        if (unzOpenCurrentFile(zip) != UNZ_OK)
        {
            std::cerr << "Cannot open file: " << filename << "\n";
            break;
        }

        std::vector<char> buffer(fileInfo.uncompressed_size);
        int bytesRead = unzReadCurrentFile(zip, buffer.data(), buffer.size());
        if (bytesRead < 0)
        {
            std::cerr << "Error reading file: " << filename << "\n";
        }
        else
        {
            namespace fs = std::filesystem;
            fs::path tmpDir = fs::temp_directory_path();
            const std::string tmpFile = std::format("{0}/mcxz{1}.bin", tmpDir.c_str(), rand());
            CFileWrap file;
            if (file.open(tmpFile.c_str(), "wb"))
            {
                file.write(buffer.data(), buffer.size());
                file.close();
                if (file.open(tmpFile.c_str(), "rb"))
                {
                    images.extract(file);
                    file.close();
                }
                fs::remove(tmpFile);
            }
        }
        unzCloseCurrentFile(zip);
    } while (unzGoToNextFile(zip) == UNZ_OK);

    unzClose(zip);
    return images.getSize() != 0;
}

/**
 * @brief Extract image from given file. Provides abstraction to support png, obl
 *        and zip sources transparently.
 *
 * @param fname
 * @param images
 * @return true
 * @return false
 */

bool extractImages(const std::string &fname, CFrameSet &images)
{
    CFileWrap sfile;
    if (fname.ends_with(".zip") && readZipFile(fname, images))
    {
        printf("%s images:%d (insize zip)\n", fname.c_str(), images.getSize());
        return true;
    }
    else if (sfile.open(fname.c_str(), "rb"))
    {
        if (images.extract(sfile))
        {
            printf("%s images:%d\n", fname.c_str(), images.getSize());
            return true;
        }
    }
    return false;
}

/**
 * @brief Process a section from the Ini File. These are sections containing files of images not any of the special sections
 *
 * @param section
 * @param files
 * @param constConfig
 * @param appSettings
 * @param colors
 * @param errors
 * @return true
 * @return false
 */
bool processSection(
    const std::string section,
    StringVector &files,
    MapStrVal &constConfig,
    const AppSettings &appSettings,
    Palette &colors,
    int &errors)
{
    std::vector<group_t> fileStats;
    bool useTileDefs = false;
    const std::string sectionName = formatTitleName(section.c_str());
    const std::string sectionBasename = getBasename(section.c_str());
    const char *tinyExt = appSettings.outputPNG ? ".png" : ".obl";
    const std::string fnameTiny = section + tinyExt;
    const std::string fnameT = section + ".mcz";

    CFrameSet imagesTiny;
    int j = 0;

    TileVector tileDefs;
    CFileWrap sfile;
    for (size_t i = 0; i < files.size(); ++i)
    {
        CFrameSet images;
        StringVector list;
        splitString(files[i], list);
        const char *fname = list[0].c_str();
        // read original images
        if (extractImages(list[0], images))
        {
            int count = images.getSize();
            int start = 0;
            int end = count;
            // parse args
            std::vector<uint8_t> ch;
            Tile tile = parseFileParams(list, constConfig, start, end, ch, useTileDefs);
            tile.basename = getBasename(fname);
            fileStats.push_back({sectionName + "_" + tile.name,
                                 count});

            // create shrink copies
            int u = 0;
            for (int i = start; i < end; ++i)
            {
                tile.ch = u < static_cast<uint8_t>(ch.size()) ? ch[u] : static_cast<uint8_t>(0);
                CFrame *s = images[i];
                CFrame *t = new CFrame;
                t->copy(s);

                if (t->hei() > 16 || t->len() > 16)
                {
                    t->resize(32, 32);
                    int shiftRight = (32 - s->len()) / 2;
                    for (int j = 0; j < shiftRight; ++j)
                    {
                        t->shiftRIGHT();
                    }
                    int shiftDown = (32 - s->hei()) / 2;
                    for (int j = 0; j < shiftDown; ++j)
                    {
                        t->shiftDOWN();
                    }
                    t->shrink();
                }
                else if (t->hei() < 16 || t->len() < 16)
                {
                    t->resize(16, 16);
                }
                imagesTiny.add(t);
                tile.define = sectionName + "_" + tile.name + (u ? std::format("_{:X}", u + 1) : ""); // tileName;
                tileDefs.push_back(tile);
                ++j;
                ++u;
            }
        }
        else
        {
            fprintf(stderr, "failed to open: %s\n", fname);
            ++errors;
        }
    }

    CFileWrap tfileTiny;
    if (!tfileTiny.open(fnameTiny.c_str(), "wb"))
    {
        printf("can't open %s\n", fnameTiny.c_str());
    }
    else if (appSettings.outputPNG)
    {
        // output to png
        unsigned char *data;
        int size;
        imagesTiny.toPng(data, size);
        tfileTiny.write(data, size);
        delete[] data;
    }
    else
    {
        // output to obl
        imagesTiny.write(tfileTiny);
    }

    printf("tiles: %d\n", imagesTiny.getSize());

    // generate tileset
    CTileSet tiles(16, 16, imagesTiny.getSize(), appSettings.pixelWidth); // create tileset
    for (int i = 0; i < imagesTiny.getSize(); ++i)
    {
        CFrame *frame = imagesTiny[i];
        uint32_t *rgbX888 = frame->getRGB();
        int pixels = frame->len() * frame->hei();
        int j;
        uint8_t rgb332[pixels];
        uint16_t rgb565[pixels];
        rgb24_t rgb24[pixels];

        switch (appSettings.pixelWidth)
        {
        case CTileSet::pixel8:
            if (colors.size() == 0)
            {
                colors[0] = 0;
            }
            for (j = 0; j < pixels; ++j)
            {
                const uint32_t &color = rgbX888[j] & 0xfff8f8f8;
                if (colors.count(color) == 0)
                {
                    colors[color] = colors.size();
                }
                rgb332[j] = colors[color];
            }
            tiles.set(i, rgb332);
            break;
        case CTileSet::pixel16:
            for (j = 0; j < pixels; ++j)
            {
                if (appSettings.encoding == ENCODING_RGB565)
                {
                    rgb565[j] = rgb888torgb565(reinterpret_cast<uint8_t *>(&rgbX888[j]));
                }
                if (appSettings.encoding == ENCODING_RGB565BGR)
                {
                    uint8_t *rgb = reinterpret_cast<uint8_t *>(&rgbX888[j]);
                    uint8_t bgr[4]{rgb[2], rgb[1], rgb[0], rgb[3]};
                    rgb565[j] = rgb888torgb565(bgr);
                }
                else if (appSettings.encoding == ENCODING_RGBX555)
                {
                    uint16_t color = (rgbX888[j] & 0xff000000) ? (0x8000 | rgb888torgb555(reinterpret_cast<uint8_t *>(&rgbX888[j]))) : 0;
                    rgb565[j] = color;
                }
            }
            tiles.set(i, rgb565);
            break;

        case CTileSet::pixel24:
            for (j = 0; j < pixels; ++j)
            {
                memcpy(&rgb24[j], &rgbX888[j], 3);
            }
            tiles.set(i, rgb24);
            break;

        case CTileSet::pixel32:
            tiles.set(i, rgbX888);
        };
    }
    tiles.write(fnameT.c_str(), appSettings.flipPixels, appSettings.headerless);

    // write MapFile
    writeMapFile(section, tileDefs, useTileDefs);

    // generate headers
    generateHeader(appSettings, section, sectionName, sectionBasename, tileDefs, fileStats, useTileDefs);

    // generate data
    if (useTileDefs)
    {
        generateData(appSettings, section, sectionBasename, tileDefs);
    }

    if (colors.size())
    {
        printf("palette: %lu\n", colors.size());
    }

    if (errors)
        fprintf(stderr, "\n===>>>>> %d errors\n\n", errors);

    printf("\n");
    return true;
}

/**
 * @brief write 256 colors polette
 *
 * @param lastTileSet
 * @param colors
 * @return true
 * @return false
 */
bool writePalette(const std::string &lastTileSet,
                  const Palette &colors)
{
    size_t colorCount = colors.size();
    if (colorCount != 0)
    {
        const int blockSize = 8;
        const int rows = 16;
        const int cols = 16;
        CFrame frame(cols * blockSize, rows * blockSize);
        std::string palettePath = lastTileSet + ".pal";
        std::string palettePngPath = lastTileSet + "-pal.png";
        uint32_t palette[colorCount];
        printf("writing palette: %s\n", palettePath.c_str());
        for (const auto &[color, idx] : colors)
        {
            palette[idx] = color;
            auto baseX = idx & 0xf;
            auto baseY = idx >> 4;
            for (int y = 0; y < blockSize; ++y)
            {
                for (int x = 0; x < blockSize; ++x)
                {
                    frame.at(baseX * blockSize + x, baseY * blockSize + y) = color;
                }
            }
        }
        FILE *tfile = fopen(palettePath.c_str(), "wb");
        fwrite(palette, sizeof(palette), 1, tfile);
        fclose(tfile);

        uint8_t *png;
        int size;
        frame.toPng(png, size);
        CFileWrap file;
        if (file.open(palettePngPath.c_str(), "wb"))
        {
            file.write(png, size);
        }
        file.close();
    }
    return true;
}

/**
 * @brief Process the .ini file designated by src abd generate the game data
 *
 * @param src
 * @param appSettings
 * @return true
 * @return false
 */
bool runJob(const char *src,
            const AppSettings &appSettings)
{
    int total_errors = 0;
    Config conf;
    Palette colors;
    std::string lastTileSet;
    StrVector sectionList;
    bool result;
    if ((result = parseConfig(conf, sectionList, src)))
    {
        MapStrVal constConfig;
        Config constLists;
        std::map<std::string, std::string> sectionRefs = {
            {"types", "TYPE"},
            {"flags", "FLAG"},
            {"speeds", "SPEED"},
            {"ai", "AI"},
        };

        for (size_t i = 0; i < sectionList.size(); ++i)
        {
            int errors = 0;
            std::string sectionName = sectionList[i];
            StringVector files = conf[sectionName];
            if (sectionRefs.count(sectionName) != 0)
            {
                processConst(
                    files,
                    sectionRefs[sectionName].c_str(),
                    constConfig[sectionName],
                    constLists[sectionName]);
            }
            else
            {
                lastTileSet = sectionName;
                printf("[%s]\n", sectionName.c_str());
                processSection(
                    sectionName,
                    files,
                    constConfig,
                    appSettings,
                    colors,
                    errors);
                total_errors += errors;
            }
        }
        writeConstFile(appSettings, constLists);
    }
    writePalette(lastTileSet, colors);
    if (total_errors)
        fprintf(stderr, "\n****>>>> total errors: %d\n", total_errors);
    else
        printf("****>>>> no error found\n");

    return result && total_errors == 0;
}

/**
 * @brief Show application usage
 *
 * @param cmd
 */
void showUsage(const char *cmd)
{
    printf(
        "mcxz tileset generator\n\n"
        "usage: \n"
        "       %s [-e?999 -r -f -p] file1.ini [file2.ini]\n"
        "\n"
        "filex.ini          job configuration\n"
        "-e?999             image/mcz encoding\n"
        "                       565 (16 bits, default)\n"
        "                       565BGR (16 bits)\n"
        "                       X555 (16 bits)\n"
        "                       X888P (8 bits + palette)\n"
        "                       888 (24 bits)\n"
        "                       X888 (32 bits)\n"
        "--app <name>       specify appName for license\n"
        "-r                 raw headerless generation (mcz raw)\n"
        "-f                 flip bytes (only applies to 16bits)\n"
        "-p                 output to png rather than obl\n"
        "-d                 strip anything not needed\n"
        "-h --help          show help\n"
        "\n",
        cmd);
}

int main(int argc, char *argv[], char *envp[])
{
    AppSettings appSettings = AppSettings{
        .pixelWidth = CTileSet::pixel16,
        .encoding = ENCODING_RGB565,
        .flipPixels = false,
        .headerless = false,
        .diet = false,
        .appName = DEFAULT_APP_NAME,
    };
    StringVector files;

    for (int i = 1; i < argc; ++i)
    {
        char *src = argv[i];
        if (src[0] == '-')
        {
            if (strcmp(src, "--help") == 0 || strcmp(src, "-h") == 0)
            {
                showUsage(argv[0]);
                return EXIT_SUCCESS;
            }
            else if (strcmp(src, "--app") == 0)
            {
                if (i + 1 < argc && argv[i + 1][0] != '-')
                {
                    appSettings.appName = argv[++i];
                    continue;
                }
                else
                {
                    fprintf(stderr, "switch: %s, missing appName\n", src);
                    return EXIT_FAILURE;
                }
            }
            else if (src[1] == 'e')
            {
                if (strcmp(&src[2], ENCODING_RGB[ENCODING_RGB565]) == 0)
                {
                    appSettings.encoding = ENCODING_RGB565;
                    appSettings.pixelWidth = 2;
                }
                if (strcmp(&src[2], ENCODING_RGB[ENCODING_RGB565BGR]) == 0)
                {
                    appSettings.encoding = ENCODING_RGB565BGR;
                    appSettings.pixelWidth = 2;
                }
                else if (strcmp(&src[2], ENCODING_RGB[ENCODING_RGBX555]) == 0)
                {
                    appSettings.encoding = ENCODING_RGBX555;
                    appSettings.pixelWidth = 2;
                }
                else if (strcmp(&src[2], ENCODING_RGB[ENCODING_RGBX888P]) == 0)
                {
                    appSettings.encoding = ENCODING_RGBX888P;
                    appSettings.pixelWidth = 1;
                }
                else if (strcmp(&src[2], ENCODING_RGB[ENCODING_RGB888]) == 0)
                {
                    appSettings.encoding = ENCODING_RGB888;
                    appSettings.pixelWidth = 3;
                }
                else if (strcmp(&src[2], ENCODING_RGB[ENCODING_RGBX888]) == 0)
                {
                    appSettings.encoding = ENCODING_RGBX888;
                    appSettings.pixelWidth = 4;
                }
                else if (src[2] == '\0')
                {
                    fprintf(stderr, "missing encoding value: %s\n", src);
                    return EXIT_FAILURE;
                }
                else
                {
                    fprintf(stderr, "invalid encoding: %s\n", src + 2);
                    return EXIT_FAILURE;
                }
                continue;
            }
            if (strlen(src) != 2)
            {
                fprintf(stderr, "invalid switch: %s\n", src);
                return EXIT_FAILURE;
            }
            else if (src[1] == 't')
            {
                test();
                continue;
            }
            else if (src[1] == 'f')
            {
                appSettings.flipPixels = true;
                continue;
            }
            else if (src[1] == 'd')
            {
                appSettings.diet = true;
                continue;
            }
            else if (src[1] == 'r')
            {
                appSettings.headerless = true;
                continue;
            }
            else if (src[1] == 'p')
            {
                appSettings.outputPNG = true;
                continue;
            }
            fprintf(stderr, "invalid switch: %s\n", src);
            return EXIT_FAILURE;
        }

        if (appSettings.flipPixels && appSettings.pixelWidth != CTileSet::pixel16)
        {
            fprintf(stderr, "invalid flag combination. cannot flip bytes if not 16bits.\n");
            return EXIT_FAILURE;
        }

        const std::string t = src;
        if (!t.ends_with(".ini"))
        {
            fprintf(stderr, "source %s doesn't end with .ini\n", src);
            return EXIT_FAILURE;
        }
        files.push_back(src);
    }

    if (files.size() == 0)
    {
        fputs("require at least one .ini file argument", stderr);
        return EXIT_FAILURE;
    }
    else
    {
        for (size_t i = 0; i < files.size(); ++i)
        {
            if (!runJob(files.at(i).c_str(), appSettings))
            {
                fputs("error encountered.", stderr);
                return EXIT_FAILURE;
            }
        }
    }
    return EXIT_SUCCESS;
}
