#include <string>
#include <cstring>
#include <vector>
#include <cstdlib>
#include "../../../shared/IFile.h"
#include "../../../shared/FileWrap.h"

typedef std::vector<std::string> StringVector;
typedef struct
{
    long ptr;
    std::string name;
    int filesize;
} fileinfo_t;

typedef std::vector<fileinfo_t> fileindex_t;

const char *AUTOGENERATED = "//////////////////////////////////////////////////\n"
                            "// autogenerated\n\n";

const char *NONE = "(none)";

long getFileSize(FILE *f)
{
    long cur = ftell(f);
    fseek(f, 0, SEEK_END);
    long size = ftell(f);
    fseek(f, cur, SEEK_SET);
    return size;
}

std::string str2upper(const std::string &in)
{
    char t[in.length() + 1];
    strcpy(t, in.c_str());
    char *p = t;
    char *d = p;
    while (*p)
    {
        if (*p == '.')
        {
            break;
        }

        if (isalpha(*p) || isdigit(*p))
        {
            *d = toupper(*p);
            ++d;
        }
        else if (*p == '-')
        {
            *d = '_';
            ++d;
        }
        ++p;
    }
    *d = 0;
    return t;
}

bool writeHeader(fileindex_t fileIndex)
{
    FILE *tfile = fopen("out/sounds.h", "wb");
    if (tfile)
    {
        fwrite(AUTOGENERATED, strlen(AUTOGENERATED), 1, tfile);
        for (int i = 0; i < fileIndex.size(); ++i)
        {
            fileinfo_t fileInfo = fileIndex[i];
            std::string name = str2upper(fileInfo.name);

            fprintf(tfile, "#define SOUND_%-20s 0x%.2x\n",
                    name.c_str(), i);
        }
        fclose(tfile);
    }

    return true;
}

bool readSndArch(const char *filename)
{
    char name[32];
    FILE *sfile = fopen(filename, "rb");
    if (sfile)
    {
        char tmp[5];
        fread(tmp, 4, 1, sfile);
        if (memcmp(tmp, "SNDX", 4))
        {
            tmp[4] = 0;
            printf("wrong signature: %s\n", tmp);
            fclose(sfile);
            return false;
        }

        int size = 0;
        int indexPtr = 0;
        int version = 0;
        fseek(sfile, 4, SEEK_SET);
        fread(&version, 2, 1, sfile);

        fseek(sfile, 6, SEEK_SET);
        fread(&size, 2, 1, sfile);
        fread(&indexPtr, 4, 1, sfile);

        // read index
        printf("\nReading index...\n\n");

        fseek(sfile, indexPtr, SEEK_SET);
        for (int i = 0; i < size; ++i)
        {
            fileinfo_t fileInfo;
            fread(&fileInfo.ptr, 4, 1, sfile);
            int fnameSize = 0;
            fread(&fnameSize, 1, 1, sfile);
            fread(name, fnameSize, 1, sfile);
            name[fnameSize] = 0;
            fileInfo.name = name;
            fread(&fileInfo.filesize, 4, 1, sfile);

            printf("name 0x%x: %s\n", i, fileInfo.name.c_str());
            printf("ptr: 0x%.4x\n", fileInfo.ptr);
            printf("size: 0x%.4x\n\n", fileInfo.filesize);
        }
        fclose(sfile);
    }
    else
    {
        printf("can't open %s\n", filename);
    }

    return true;
}

bool readSndArch(IFile &file)
{
    char name[32];
    char tmp[5];
    file.read(tmp, 4);
    if (memcmp(tmp, "SNDX", 4) != 0)
    {
        tmp[4] = 0;
        printf("wrong signature: %s\n", tmp);
        file.close();
        return false;
    }

    int size = 0;
    int indexPtr = 0;
    int version = 0;
    file.seek(4);
    file.read(&version, 2);

    file.seek(6);
    file.read(&size, 2);
    file.read(&indexPtr, 4);

    // read index
    printf("\nReading index...\n\n");

    file.seek(indexPtr);
    for (int i = 0; i < size; ++i)
    {
        fileinfo_t fileInfo;
        file.read(&fileInfo.ptr, 4);
        int fnameSize = 0;
        file.read(&fnameSize, 1);
        file.read(name, fnameSize);
        name[fnameSize] = 0;
        fileInfo.name = name;
        file.read(&fileInfo.filesize, 4);

        printf("name: %s\n", fileInfo.name.c_str());
        printf("ptr: 0x%.4x\n", fileInfo.ptr);
        printf("size: 0x%.4x\n\n", fileInfo.filesize);
    }
    file.close();

    return true;
}

bool processConfig(StringVector &files)
{
    const char *fname = "data.ini";
    CFileWrap file;
    char *data = nullptr;
    if (file.open(fname, "rb"))
    {
        int size = file.getSize();
        data = new char[size + 1];
        data[size] = 0;
        file.read(data, size);
        file.close();
    }
    else
    {
        printf("can't read %s", fname);
        return false;
    }

    char *p = data;
    int line = 0;
    while (p && *p)
    {
        ++line;
        char *n = strstr(p, "\n");
        if (n)
        {
            *n = '\0';
            ++n;
        }

        char *c = strstr(p, "#");
        if (c)
        {
            *c = '\0';
        }

        while (isspace(*p))
        {
            ++p;
        }

        char *s = p + strlen(p) - 1;
        while (s >= p && isspace(*s))
        {
            *s = 0;
            --s;
        }

        if (*p)
        {
            files.push_back(p);
        }
        p = n;
    }
    delete[] data;
    return true;
}

bool writeSoundPak(const char *outFname, StringVector &files, fileindex_t &fileIndex)
{
    FILE *tfile = fopen(outFname, "wb");
    if (!tfile)
    {
        printf("can't write %s\n", outFname);
        return false;
    }

    std::vector<long> index;
    // fileindex_t fileIndex;
    fwrite("SNDX", 4, 1, tfile);
    fwrite("\0\0\0\0", 4, 1, tfile);
    fwrite("\0\0\0\0", 4, 1, tfile);

    for (int i = 0; i < files.size(); ++i)
    {
        const char *name = files[i].c_str();
        char srcFile[128];
        sprintf(srcFile, "data/%s", name);
        long ptr = ftell(tfile);
        fileinfo_t fileInfo = {ptr, name, 0};
        if (strcmp(name, NONE))
        {
            FILE *sfile = fopen(srcFile, "rb");
            if (sfile)
            {
                long filesize = getFileSize(sfile);
                char *buf = new char[filesize];
                fread(buf, filesize, 1, sfile);
                fclose(sfile);

                printf("%s -> %d bytes (0x%x)\n", name, filesize, filesize);

                fileInfo.filesize = filesize;
                fwrite(buf, filesize, 1, tfile);
                delete[] buf;
            }
            else
            {
                printf("can't read %s\n", srcFile);
            }
        }

        fileIndex.push_back(fileInfo);
    }

    // write index
    printf("\nwriting index...\n\n");
    long indexPtr = ftell(tfile);
    size_t size = fileIndex.size();
    for (int i = 0; i < fileIndex.size(); ++i)
    {
        fileinfo_t fileInfo = fileIndex[i];
        fwrite(&fileInfo.ptr, 4, 1, tfile);
        int fnameSize = fileInfo.name.length();
        fwrite(&fnameSize, 1, 1, tfile);
        fwrite(fileInfo.name.c_str(), fnameSize, 1, tfile);
        fwrite(&fileInfo.filesize, 4, 1, tfile);

        // printf("name: %s\n", fileInfo.name.c_str());
        // printf("ptr: 0x%.4x\n", fileInfo.ptr);
        // printf("size: 0x%.4x\n\n", fileInfo.filesize);
    }
    fseek(tfile, 6, SEEK_SET);
    fwrite(&size, 2, 1, tfile);
    fwrite(&indexPtr, 4, 1, tfile);

    fclose(tfile);
    return true;
}

int main()
{
    const char *outFname = "out/sounds.dat";
    StringVector files;
    fileindex_t fileIndex;

    if (!processConfig(files) || !writeSoundPak(outFname, files, fileIndex))
    {
        exit(EXIT_FAILURE);
    }
    writeHeader(fileIndex);

    // readSndArch(outFname);
    CFileWrap file;
    if (file.open(outFname, "rb"))
    {
        readSndArch(file);
        file.close();
    }
    else
    {
        printf("can't read %s\n", outFname);
    }

    exit(EXIT_SUCCESS);
}